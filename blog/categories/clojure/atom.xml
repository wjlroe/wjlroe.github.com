<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: clojure | Will Roe&#146;s blog]]></title>
  <link href="http://blog.wjlr.org.uk/blog/categories/clojure/atom.xml" rel="self"/>
  <link href="http://blog.wjlr.org.uk/"/>
  <updated>2015-04-07T12:59:50+01:00</updated>
  <id>http://blog.wjlr.org.uk/</id>
  <author>
    <name><![CDATA[Will Roe]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Serialist Micro Piano Trio No. 1]]></title>
    <link href="http://blog.wjlr.org.uk/2015/03/23/serial-micro-piano-trio-no-1.html"/>
    <updated>2015-03-23T20:00:00+00:00</updated>
    <id>http://blog.wjlr.org.uk/2015/03/23/serial-micro-piano-trio-no-1</id>
    <content type="html"><![CDATA[<p>My first &#8220;released&#8221; (algorithmically generated) composition is a micro
piano trio in a <a href="http://en.wikipedia.org/wiki/Serialism">serialist</a> style.</p>

<!--more-->


<p>It all started when I borrowed the book <a href="https://www.goodreads.com/book/show/3150827-simple-composition">Simple Composition</a> by
<a href="http://en.wikipedia.org/wiki/Charles_Wuorinen">Charles Wuorinen</a> from the Sussex University library (I was
studying Computer Science &amp; Artificial Intelligence at the time, some
years ago).</p>

<p><figure class="img fillwidth"><img src="http://blog.wjlr.org.uk/images/University_of_Sussex_Library.jpg" alt="Sussex Uni Library" title="Sussex Uni Library"><figcaption>Sussex University Library &#8211; Photo Public Domain, Wikipedia, Filtered</figcaption></figure></p>

<p>More recently I tracked down a copy so that I could have a go at
writing twelve-tone music. This book explains the basics of composing
in the <a href="http://en.wikipedia.org/wiki/Twelve-tone_technique">twelve tone technique</a> created by <a href="http://en.wikipedia.org/wiki/Arnold_Schoenberg">Arnold Schoenberg</a>.
Some days ago I started playing around with the concepts from that
book in <a href="http://overtone.github.io/">Overtone</a>. It was a lot of fun.</p>

<p><div class='embed tweet'><blockquote class="twitter-tweet"><p>I might be playing with <a href="https://twitter.com/overtone">@overtone</a> possibly <a href="https://twitter.com/hashtag/clojure?src=hash">#clojure</a> <a href="http://t.co/8KRPc2qmpr">pic.twitter.com/8KRPc2qmpr</a></p>&mdash; Will Roe (@wjlroe) <a href="https://twitter.com/wjlroe/status/575775558082150402">March 11, 2015</a></blockquote>
<script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script></div></p>

<p>If you&#8217;re not familiar with twelve-tone composition or serialism in
music, you could do a lot worse than to watch this awesome video by
<a href="http://vihart.com">ViHart</a>:</p>

<iframe width="560" height="315" src="https://www.youtube.com/embed/4niz8TfY794" frameborder="0" allowfullscreen></iframe>


<h2>The code</h2>

<p>I used a library called <a href="https://github.com/ctford/leipzig">Leipzig</a> written by <a href="http://literateprogrammer.blogspot.co.uk/">Chris Ford</a> to build
up the composition from an initial tone row (a set of 12 integers),
via several functional transformations of the tone row and into 3
instrumental parts: piano, violin and cello.</p>

<p>Since this piece uses a randomly-generated tone row and
randomly-generated sequence of both note duration and playing style
(vibrato, non-vibrato or pizzicato),
it&#8217;s not actually reproducible from the code. The code is useful
mainly for encoding the basic form of the piece and the parameters
of the work (such as instruments, length of the piece, which elements
are random and which aren&#8217;t etc.).</p>

<p>In future I will work out some way to capture the notes being
generated. The simplest way to do this would be to save all the
structures produced by the <code>piano-trio</code> function into an <a href="https://github.com/edn-format/edn">EDN</a> file,
which could be trivially played back at a later date. Transformation
of that data into traditional musical notation wouldn&#8217;t be too tricky
either.</p>

<p>The structure of this piece consists of 3 instrumental parts played in
parallel. The main function is
<a href="https://github.com/wjlroe/serial/blob/micro-piano-trio-1/src/serial/twelve_tone.clj#L200-L213"><code>piano-trio</code></a>
and is inline below:</p>

<pre><code class="clojure">(defn piano-trio
  [bpm tone-row]
  (in-tempo
   bpm
   (with
    (-&gt;&gt; (total-serial tone-row)
         (play-on :cello)
         (serial-style :cello))
    (-&gt;&gt; (total-serial tone-row)
         (play-on :violin)
         (serial-style :violin))
    (-&gt;&gt; (total-serial tone-row)
         (play-on :piano)
         (serial-style :piano)))))
</code></pre>

<p>The most interesting aspect as it relates to musical transformation is
the definition of retrograde, inversion and retrograde-inversion:</p>

<pre><code class="clojure">(defn retrograde
  [row]
  (reverse row))

(defn inversion
  [row]
  (map - row))

(def retrograde-inversion
  (comp retrograde inversion))
</code></pre>

<p>It was for this reason - the applicability of pure functions and
functional composition - that I felt <a href="http://overtone.github.io/">overtone</a> and Clojure were such a
good fit for writing <a href="http://en.wikipedia.org/wiki/Serialism">serialist</a> music. It&#8217;s even more applicable to
12-tone composition than tonal (diatonic) music since the rules are so
much more mechanistic.</p>

<h2>The recording</h2>

<p><iframe width="100%" height="166" scrolling="no" frameborder="no" src="https://w.soundcloud.com/player/?url=https%3A//api.soundcloud.com/tracks/197309694&amp;color=ff5500&amp;auto_play=false&amp;hide_related=false&amp;show_comments=true&amp;show_user=true&amp;show_reposts=false"></iframe></p>


<p>I had a lot of fun exploring serialism through Overtone and the
Leipzig library. I was inspired to release this little track and to
spend more time on code like this when I watched a great talk called
<a href="https://www.youtube.com/watch?v=kovJHzQNsg0">Make Art, Not Apps</a> by <a href="https://twitter.com/ThisIsJohnBrown">@ThisIsJohnBrown</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Fast string interpolation in ClojureScript]]></title>
    <link href="http://blog.wjlr.org.uk/2015/01/17/fast-string-interpolation-cljs.html"/>
    <updated>2015-01-17T03:30:00+00:00</updated>
    <id>http://blog.wjlr.org.uk/2015/01/17/fast-string-interpolation-cljs</id>
    <content type="html"><![CDATA[<p>In my
<a href="/2015/01/15/string-interpolation-clojure.html">previous post on string interpolation in Clojure</a>,
I benchmarked <code>&lt;&lt;</code> from <code>core.incubator</code> and it proved both useful and
performant. But can this useful macro be used from ClojureScript? Yes.</p>

<!--more-->


<p>Add <code>core.incubator</code> to your dependencies in <code>project.clj</code> of your
ClojureScript project:</p>

<pre><code class="clojure">(defproject some-project "1.0.0-SNAPSHOT"
  :dependencies [...
                 [org.clojure/core.incubator "0.1.3"]
                 ...]
</code></pre>

<p>Now you can require the <code>strint</code> macros in your ClojureScript source
(e.g. in <code>src/cljs/app/core.cljs</code>):</p>

<pre><code class="clojure">(ns app.core
  (:require-macros [clojure.core.strint :as strint]))
</code></pre>

<p>Now you can use the fast string interpolator thus:</p>

<pre><code class="clojure">(enable-console-print!)

(let [name "Ethel Smyth"
      profession "Composer"
      born 1858]
  (println
   (strint/&lt;&lt; "The person named ~{name} works as a ~{profession}
and was born in ~{born}")))
</code></pre>

<p>That&#8217;s it!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Fast string interpolation in Clojure]]></title>
    <link href="http://blog.wjlr.org.uk/2015/01/15/string-interpolation-clojure.html"/>
    <updated>2015-01-15T21:55:00+00:00</updated>
    <id>http://blog.wjlr.org.uk/2015/01/15/string-interpolation-clojure</id>
    <content type="html"><![CDATA[<!--more-->


<p>There are two main ways to build strings in Clojure: <a href="https://clojuredocs.org/clojure.core/str"><code>str</code></a> and
<a href="https://clojuredocs.org/clojure.core/format"><code>format</code></a>. <code>str</code> essentially does string concatenation like
this:</p>

<pre><code class="clojure">(str "This is a sentence with " some " variables ")
</code></pre>

<p>I find <code>str</code> forms somewhat unreadable, especially on one line. They
require the reader to mentally keep track of quote marks and spaces
around variables.</p>

<p>On the other hand, <code>format</code> offers a fully-featured string interpolation
function using Java&#8217;s <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Formatter.html">Formatter</a> class:</p>

<pre><code class="clojure">(format "This string has another string: %s in it and a number: %.2f"
         "hello!"
         30.1)
</code></pre>

<p>In ruby we might use string interpolation thus:</p>

<pre><code class="ruby">def str_interpolate name, profession, born
  puts "The person named #{name} works as a #{profession} and was born in #{born}"
end

str_interpolate "Ethel Smyth", "Composer", 1858
</code></pre>

<p>The advantage of string interpolation like this is how readable the
code can be.</p>

<p>The problem with prefering <code>format</code> over <code>str</code> is the difference in
performance. <code>format</code> is a lot more complex and if all you&#8217;re doing is
string concatenation, then it&#8217;ll not do the job as quickly as <code>str</code>
does (which uses a <a href="http://docs.oracle.com/javase/8/docs/api/java/lang/StringBuilder.html">StringBuilder</a> under the hood).</p>

<h2>Benchmarks!</h2>

<p>The following code uses the <a href="https://github.com/hugoduncan/criterium">Criterium</a> library aliased to <code>bench</code>.</p>

<p>First let&#8217;s define a function using <code>str</code> and benchmark it:</p>

<pre><code class="clojure">(defn str-concat-fun
  [name profession born]
  (str "The person named "
       name
       " works as a "
       profession
       " and was born in "
       born))

(bench/bench (str-concat-fun name profession born))
</code></pre>

<p>Which results in (256ns):</p>

<pre><code>Evaluation count : 241104540 in 60 samples of 4018409 calls.
             Execution time mean : 256.236563 ns
    Execution time std-deviation : 4.617404 ns
   Execution time lower quantile : 250.226629 ns ( 2.5%)
   Execution time upper quantile : 266.339191 ns (97.5%)
                   Overhead used : 1.166050 ns

Found 5 outliers in 60 samples (8.3333 %)
        low-severe       5 (8.3333 %)
 Variance from outliers : 7.7764 % Variance is slightly inflated by outliers
</code></pre>

<p>Now let&#8217;s check the <code>format</code> version:</p>

<pre><code class="clojure">(defn format-fun
  [name profession born]
  (format "The person named %s works as a %s and was born in %d"
          name
          profession
          born))

(bench/bench (format-fun name profession born))
</code></pre>

<p>Which results in (1.7µs):</p>

<pre><code>Evaluation count : 34997760 in 60 samples of 583296 calls.
             Execution time mean : 1.703759 µs
    Execution time std-deviation : 36.732362 ns
   Execution time lower quantile : 1.663752 µs ( 2.5%)
   Execution time upper quantile : 1.779579 µs (97.5%)
                   Overhead used : 1.166050 ns

Found 2 outliers in 60 samples (3.3333 %)
        low-severe       2 (3.3333 %)
 Variance from outliers : 9.4397 % Variance is slightly inflated by outliers
</code></pre>

<p>That&#8217;s not good, but not entirely unexpected. An order of magnitude
slower to use <code>format</code> for string contatenation tasks like this.</p>

<p>One of the advantages of Clojure is the promise of powerful,
expressive abstractions and not having to compromise on those
abstractions to achieve performance. In a <a href="http://cemerick.com/2009/12/04/string-interpolation-in-clojure/">blog post</a> about
string interpolation in Clojure, Chas Emerick proposes a macro for
simple string interpolation that would behave much like Ruby&#8217;s does.
This has made its way into the <a href="https://github.com/clojure/core.incubator/">core.incubator</a> project and can be
used in projects today.</p>

<p>To require it, add <code>core.incubator</code> to your project&#8217;s dependencies and
add the following to any namespace that needs it:</p>

<pre><code class="clojure">(ns example...)
  (:require [clojure.core.strint :refer [&lt;&lt;]]))
</code></pre>

<p>So now we can define a function like the others using this new macro:</p>

<pre><code class="clojure">(defn interpolation-fun
  [name profession born]
  (&lt;&lt; "The person named ~{name} works as a ~{profession} and was born in ~{born}"))

(bench/bench (interpolation-fun name profession born))
</code></pre>

<p>And this results in (272ns):</p>

<pre><code>Evaluation count : 222317940 in 60 samples of 3705299 calls.
             Execution time mean : 271.580867 ns
    Execution time std-deviation : 2.117763 ns
   Execution time lower quantile : 267.593081 ns ( 2.5%)
   Execution time upper quantile : 274.826087 ns (97.5%)
                   Overhead used : 1.166050 ns
</code></pre>

<p>Not bad! Ever so slightly slower than the <code>str</code> version but a
performance penalty well worth paying for to get more expressive
string interpolation I feel.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Secret Santa in core.logic]]></title>
    <link href="http://blog.wjlr.org.uk/2014/12/28/secret-santa-logic.html"/>
    <updated>2014-12-28T19:04:00+00:00</updated>
    <id>http://blog.wjlr.org.uk/2014/12/28/secret-santa-logic</id>
    <content type="html"><![CDATA[<p>Logic programming is an odd beast. As I lounged around over the
holidays I tried to work out how to write a Secret Santa algorithm
using core.logic. It seemed like the obvious choice but I quickly
realised I&#8217;d bitten off more than I could chew.</p>

<!--more-->


<h2>Simple Secret Santa</h2>

<p>Your common or garden Secret Santa consists of putting names in a hat
and picking them out again, ensuring you don&#8217;t pick yourself. Suitable
for offices and other groups of awkward strangers and acquaintances.</p>

<p>We need <code>core.logic</code> imported, so here&#8217;s the namespace declaration
(note that both <code>clojure.core</code> and <code>clojure.core.logic</code> define <code>==</code>
for totally different purposes. I have never used <code>clojure.core/==</code> so
I&#8217;m a bit hazy as to what it&#8217;s for - we exclude it so they don&#8217;t clash):</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="kd">ns </span><span class="nv">secret-santa.core</span>
</span><span class='line'>  <span class="p">(</span><span class="ss">:refer-clojure</span> <span class="ss">:exclude</span> <span class="p">[</span><span class="nv">==</span><span class="p">])</span>
</span><span class='line'>  <span class="p">(</span><span class="ss">:require</span> <span class="p">[</span><span class="nv">clojure.core.logic</span> <span class="ss">:refer</span> <span class="ss">:all</span><span class="p">]</span>
</span><span class='line'>            <span class="p">[</span><span class="nv">clojure.core.logic.pldb</span> <span class="ss">:refer</span> <span class="ss">:all</span><span class="p">]))</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>We&#8217;ll start by defining a relation:</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="nf">db-rel</span> <span class="nv">santa</span> <span class="nv">p</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>This is so that we can constrain values to only those names we&#8217;ve
defined are santas (otherwise you get weird logic variables and nobody
wants to deal with that noise).</p>

<p>Now for the Secret Santa function. It takes a list of friend names
(not actually a requirement that they are friends, they may not be
after exchanging presents) and returns a list of lists. Each inner
list is a pair of giver and receiver of presents.</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="kd">defn </span><span class="nv">simple-secret-santa</span>
</span><span class='line'>  <span class="p">[</span><span class="nv">friends</span><span class="p">]</span>
</span><span class='line'>  <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">facts</span> <span class="p">(</span><span class="nf">coll-&gt;db</span> <span class="p">(</span><span class="nb">for </span><span class="p">[</span><span class="nv">friend</span> <span class="nv">friends</span><span class="p">]</span>
</span><span class='line'>                           <span class="p">[</span><span class="nv">santa</span> <span class="nv">friend</span><span class="p">]))</span>
</span><span class='line'>        <span class="nv">num</span> <span class="p">(</span><span class="nb">count </span><span class="nv">friends</span><span class="p">)</span>
</span><span class='line'>        <span class="nv">givers</span> <span class="p">(</span><span class="nf">repeatedly</span> <span class="nv">num</span> <span class="nv">lvar</span><span class="p">)</span>
</span><span class='line'>        <span class="nv">receivers</span> <span class="p">(</span><span class="nf">repeatedly</span> <span class="nv">num</span> <span class="nv">lvar</span><span class="p">)]</span>
</span><span class='line'>    <span class="p">(</span><span class="nf">-&gt;&gt;</span> <span class="p">(</span><span class="nf">with-db</span> <span class="nv">facts</span>
</span><span class='line'>           <span class="p">(</span><span class="nf">run*</span> <span class="p">[</span><span class="nv">q</span><span class="p">]</span>
</span><span class='line'>             <span class="p">(</span><span class="nf">everyg</span> <span class="nv">santa</span> <span class="nv">givers</span><span class="p">)</span>
</span><span class='line'>             <span class="p">(</span><span class="nf">everyg</span> <span class="nv">santa</span> <span class="nv">receivers</span><span class="p">)</span>
</span><span class='line'>             <span class="p">(</span><span class="nf">distincto</span> <span class="nv">givers</span><span class="p">)</span>
</span><span class='line'>             <span class="p">(</span><span class="nf">distincto</span> <span class="nv">receivers</span><span class="p">)</span>
</span><span class='line'>             <span class="p">(</span><span class="nf">pairupo</span> <span class="nv">givers</span> <span class="nv">receivers</span> <span class="nv">q</span><span class="p">)))</span>
</span><span class='line'>      <span class="p">(</span><span class="nb">map </span><span class="nv">sort</span><span class="p">)</span>
</span><span class='line'>      <span class="nv">distinct</span>
</span><span class='line'>      <span class="nv">rand-nth</span><span class="p">)))</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>If we call it thus:</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="nf">simple-secret-santa</span> <span class="p">[</span><span class="s">&quot;Tommen&quot;</span> <span class="s">&quot;Gregor&quot;</span> <span class="s">&quot;Daenerys&quot;</span> <span class="s">&quot;Arya&quot;</span><span class="p">])</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>Then we should get the following as a result:</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">([</span><span class="s">&quot;Arya&quot;</span> <span class="s">&quot;Gregor&quot;</span><span class="p">]</span>
</span><span class='line'> <span class="p">[</span><span class="s">&quot;Daenerys&quot;</span> <span class="s">&quot;Tommen&quot;</span><span class="p">]</span>
</span><span class='line'> <span class="p">[</span><span class="s">&quot;Gregor&quot;</span> <span class="s">&quot;Daenerys&quot;</span><span class="p">]</span>
</span><span class='line'> <span class="p">[</span><span class="s">&quot;Tommen&quot;</span> <span class="s">&quot;Arya&quot;</span><span class="p">])</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>Please note my chronic lack of imagination evidenced by my lazily
using characters from Game of Thrones who would likely not be involved
in this kind of tomfoolery.</p>

<p>We need a helper function for pairing people up now:</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="nf">defne</span> <span class="nv">pairupo</span>
</span><span class='line'>  <span class="p">[</span><span class="nv">givers</span> <span class="nv">receivers</span> <span class="nv">pairs</span><span class="p">]</span>
</span><span class='line'>  <span class="p">([()</span> <span class="p">()</span> <span class="p">()])</span>
</span><span class='line'>  <span class="p">([[</span><span class="nv">g</span> <span class="k">. </span><span class="nv">gs</span><span class="p">]</span> <span class="p">[</span><span class="nv">r</span> <span class="k">. </span><span class="nv">rs</span><span class="p">]</span> <span class="p">[</span><span class="nv">p</span> <span class="k">. </span><span class="nv">ps</span><span class="p">]]</span>
</span><span class='line'>   <span class="p">(</span><span class="nf">!=</span> <span class="nv">g</span> <span class="nv">r</span><span class="p">)</span>
</span><span class='line'>   <span class="p">(</span><span class="nb">== </span><span class="nv">p</span> <span class="p">[</span><span class="nv">g</span> <span class="nv">r</span><span class="p">])</span>
</span><span class='line'>   <span class="p">(</span><span class="nf">pairupo</span> <span class="nv">gs</span> <span class="nv">rs</span> <span class="nv">ps</span><span class="p">)))</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>The mind-bending nature of that function can be rather confusing. In
core.logic (as with <a href="http://minikanren.org">miniKanren</a> and others),
it&#8217;s common for an &#8220;output
value&#8221; to be one of the parameters, in this case the 3rd parameter
(<code>pairs</code>). This function defines a relationship between the parameters
provided so you can call it with <code>givers</code> and <code>pairs</code> and it&#8217;ll fill
in the blanks for the <code>receivers</code> value (effectively unzipping the
<code>pairs</code> value), which is pretty neat.</p>

<h3>Unify what?</h3>

<p>It&#8217;s crucial to understand the <code>clojure.core.logic/==</code> unification
function to understand how any of this works. It looks like an
equality test from one of those other programming languages we shall
not mention here, but it isn&#8217;t like that. Sometimes I thought of it as
a kind of wishful-thinking-equality - a sort of &#8220;wouldn&#8217;t it be just
lovely if these things were the same&#8221;.</p>

<p>Taking an example from
<a href="https://github.com/clojure/core.logic/wiki/A-Core.logic-Primer">the core.logic wiki</a>:</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="nf">run*</span> <span class="p">[</span><span class="nv">q</span><span class="p">]</span>
</span><span class='line'>  <span class="p">(</span><span class="nf">fresh</span> <span class="p">[</span><span class="nv">a</span><span class="p">]</span>
</span><span class='line'>    <span class="p">(</span><span class="nf">membero</span> <span class="nv">a</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">])</span>
</span><span class='line'>    <span class="p">(</span><span class="nf">membero</span> <span class="nv">q</span> <span class="p">[</span><span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span><span class="p">])</span>
</span><span class='line'>    <span class="p">(</span><span class="nb">== </span><span class="nv">a</span> <span class="nv">q</span><span class="p">)))</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>In the above we are asking core.logic for the possible values of <code>q</code>
(the output variable). We start using a new logic variable <code>a</code> which
we unify with <code>q</code> using the <code>==</code> unification function. That is to say,
all solutions must satisfy the equation <code>a = q</code>, they must have the
same value. Core.logic tends to add &#8216;o&#8217; to the end of common function
names so <code>(membero a [1 2 3])</code> isn&#8217;t a boolean predicate function for
testing for list membership, it attempts to make that statement true.
With simply that statement - <code>a</code> can be 1 or 2 or 3. The next line
asserts that <code>q</code> is a member of the list <code>[3 4 5]</code> so its value can be
3 or 4 or 5. The last line unifies <code>a</code> and <code>q</code> so they must have the
same value. We can tell that the only cross-over between the 2 lists
already mentioned is the value 3, so <code>q</code> can only be 3. <code>run*</code> returns
a list of all possible solutions so in fact we will get a single
element list: <code>(3)</code> as the result from that code.</p>

<p>The input of our Secret Santa function will be a list of names
(strings), so it&#8217;d be useful to turn that list of names into a
database that we can constrain our logic functions on:</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="kd">defn </span><span class="nv">coll-&gt;db</span>
</span><span class='line'>  <span class="p">[</span><span class="nv">coll</span><span class="p">]</span>
</span><span class='line'>  <span class="p">(</span><span class="nb">apply </span><span class="nv">db</span> <span class="nv">coll</span><span class="p">))</span>
</span></code></pre></td></tr></table></div></figure></p>

<p><a href="http://crossclj.info/fun/clojure.core.logic.pldb/db.html"><code>clojure.core.logic.pldb/db</code></a> takes a variable number of parameters and
returns a database with those facts contained. We want to call it with
a collection so <code>apply</code> comes in handy here. Effectively you can use
<code>apply</code> to turn this: <code>(apply somefn [arg1 arg2 arg3])</code> into <code>(somefn
arg1 arg2 arg3)</code></p>

<h3>How does it work again?</h3>

<p>Let&#8217;s concentrate on the core part of the function:</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="nf">with-db</span> <span class="nv">facts</span>
</span><span class='line'>  <span class="p">(</span><span class="nf">run*</span> <span class="p">[</span><span class="nv">q</span><span class="p">]</span>
</span><span class='line'>    <span class="p">(</span><span class="nf">everyg</span> <span class="nv">santa</span> <span class="nv">givers</span><span class="p">)</span>
</span><span class='line'>    <span class="p">(</span><span class="nf">everyg</span> <span class="nv">santa</span> <span class="nv">receivers</span><span class="p">)</span>
</span><span class='line'>    <span class="p">(</span><span class="nf">distincto</span> <span class="nv">givers</span><span class="p">)</span>
</span><span class='line'>    <span class="p">(</span><span class="nf">distincto</span> <span class="nv">receivers</span><span class="p">)</span>
</span><span class='line'>    <span class="p">(</span><span class="nf">pairupo</span> <span class="nv">givers</span> <span class="nv">receivers</span> <span class="nv">q</span><span class="p">)))</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>We are asking for all the solutions where every item in the <code>givers</code>
collection is a santa and every item in the <code>receivers</code> collection is
a santa (lines 3 and 4). This ensures that those collections contain
only valid santa names and not logic variables or numbers or anything
else. There&#8217;s something subtle about this - it&#8217;s not simply an
assertion. core.logic will make those statements true in every way
they can. One possible version of that (assuming there were 4 names
input to the function) is that <code>givers =
["Arya" "Arya" "Arya" "Arya"]</code>. That&#8217;s nonsensical for our purposes
(remember we mean to zip up these collections so the first giver is
giving to the first receiver, the 2nd giver to the 2nd receiver and so
on). So then we ensure that the collection of givers has distinct
elements in it (line 5), saying the same about receivers on line 6. If
you imagine core.logic has assembled all the combinations of values
that are santas first - imagine now it throws away any where values
repeat. One of the remaining values for <code>givers</code> will be
[&#8220;Arya&#8221; &#8220;Gregor&#8221; &#8220;Tommen&#8221; &#8220;Daenerys&#8221;]. There will be more. How many?</p>

<h3>Derangements, subfactorials, oh my!</h3>

<p>The mathematical name for the number of unique permutations of
elements in a set (that are different from their original arrangement)
is the number of
<a href="https://en.wikipedia.org/wiki/Derangement">derangements</a> or the subfactorial.</p>

<p>Roughly speaking, Secret Santa is a special case of finding a
derangement of names. When you have 4 names, there are 9 derangements.</p>

<p>Here is some clojure that calculates that:</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="kd">defn </span><span class="nv">derangements</span>
</span><span class='line'>  <span class="s">&quot;Calculate the number of derangements of n elements.&quot;</span>
</span><span class='line'>  <span class="p">[</span><span class="nv">n</span><span class="p">]</span>
</span><span class='line'>  <span class="p">(</span><span class="nf">condp</span> <span class="nb">= </span><span class="nv">n</span>
</span><span class='line'>    <span class="mi">0</span> <span class="mi">1</span>
</span><span class='line'>    <span class="mi">1</span> <span class="mi">0</span>
</span><span class='line'>    <span class="p">(</span><span class="nb">* </span><span class="p">(</span><span class="nb">dec </span><span class="nv">n</span><span class="p">)</span>
</span><span class='line'>       <span class="p">(</span><span class="nb">+ </span><span class="p">(</span><span class="nf">derangements</span> <span class="p">(</span><span class="nb">dec </span><span class="nv">n</span><span class="p">))</span>
</span><span class='line'>          <span class="p">(</span><span class="nf">derangements</span> <span class="p">(</span><span class="nb">- </span><span class="nv">n</span> <span class="mi">2</span><span class="p">))))))</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>This algorithm is primarily useful for checking your results in unit
tests for example. Another way to use it is as the parameter to
<code>run</code> - you can ask for all the possible derangements of friends. I
didn&#8217;t have much luck with that because I misunderstood the values
that my logic code was producing, also there is no need to know
beforehand how many combinations are possible since you only want one.</p>

<h2>Further improvements</h2>

<p>One weakness of the solutions described above is that they model the
relationship between the gift giver and receiver as a binary - allowed
or not. It would be useful to be able to first attempt to solve the
problem under ideal conditions before falling back to less and less
ideal solutions. For example, it&#8217;s not ideal to have people paired up
symmetrically - it&#8217;s just a bit boring that way. It&#8217;s more optimal to
assign Santas in a circle, which makes it slightly more difficult to
identify who&#8217;s assigned who.</p>

<p>Finding all possible solutions is extremely slow in core.logic (at
least, the way I&#8217;ve written it) so this could do with a fair amount of
optimisation.</p>

<p>I punted the problem of picking a solution out of possible solutions
to the combination of <code>(map sort)</code>, <code>distinct</code> and <code>rand-nth</code>. This
isn&#8217;t really necessary, I could have told core.logic what constitutes
a distinct solution (it doesn&#8217;t realise that order of pairings doesn&#8217;t
matter) and then simply picked one. My brain hurt so much by that
point that I decided to call it a day and move on to more interesting
problems, like</p>

<h2>Final thoughts</h2>

<p>I had a great deal of difficulty writing the <code>pairupo</code> function,
largely because all the various <code>defne</code>/<code>defnu</code>/<code>defna</code> confused me -
I still couldn&#8217;t tell you what they do. This was partly due to me
moving from a real problem (Secret Santa) to the implementation in
core.logic on the basis of sketchy logic programming knowledge, so I
missed a lot of subtlety related to <code>conde</code> which is crucial for
understanding this stuff. The official documentaion for core.logic is
extremely sparse also, you are very much on your own if the problem
you want to solve isn&#8217;t Sudoku or the Typed Lambda Calculus (it
boggles my mind that that is on the
<a href="https://github.com/clojure/core.logic/wiki/Examples">Examples</a>
wiki page, I&#8217;m not sure if the intention is to educate or
obfuscate there).</p>

<p>I hope that a bit more blogging from mere mortals like myself might
help others grok this mind-mending area of programming.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ludum Dare 24 - I'm taking part]]></title>
    <link href="http://blog.wjlr.org.uk/2012/08/22/ludum-dare-24-i-slash-m-taking-part.html"/>
    <updated>2012-08-22T02:15:00+01:00</updated>
    <id>http://blog.wjlr.org.uk/2012/08/22/ludum-dare-24-i-slash-m-taking-part</id>
    <content type="html"><![CDATA[<p>I shall be making an attempt to build a game in 48 hours for <a href="http://www.ludumdare.com/compo/">Ludum Dare 24</a>, for the first time.</p>

<p>My tools will be:</p>

<ul>
<li><strong>Language</strong>: Clojure + ClojureScript (targeting Javascript)</li>
<li><strong>Engine</strong>: My brain and HTML Canvas&#8230;mainly canvas</li>
<li><strong>Libraries</strong>: probably at least <a href="https://github.com/ibdknox/monet">Monet</a></li>
<li><strong>Music</strong>: I have no idea, whatever I can work out how to use</li>
<li><strong>Graphics</strong>: Pixen, Pixelmator, that sort of thing probably</li>
</ul>


<p>I&#8217;m gonna have fun but since I&#8217;m breaking rule 1 - know the tools (I don&#8217;t know any possible tools) this is going to be intense.</p>

<p>Have fun everyone!</p>
]]></content>
  </entry>
  
</feed>
